#!/bin/bash

# Morgus Pre-Commit Hook
# Prevents accidental commit of secrets and sensitive data

echo "ğŸ” Running Morgus pre-commit security checks..."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

ERRORS_FOUND=0

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo -e "${GREEN}âœ“ No files staged for commit${NC}"
    exit 0
fi

# ===========================================
# CHECK 1: Stripe Keys
# ===========================================
echo "  Checking for Stripe keys..."
STRIPE_PATTERN="sk_(test|live)_[A-Za-z0-9]{20,}"
if echo "$STAGED_FILES" | xargs grep -lE "$STRIPE_PATTERN" 2>/dev/null; then
    echo -e "${RED}âŒ BLOCKED: Stripe secret key detected!${NC}"
    echo "   Files containing Stripe keys:"
    echo "$STAGED_FILES" | xargs grep -lE "$STRIPE_PATTERN" 2>/dev/null
    ERRORS_FOUND=1
fi

# ===========================================
# CHECK 2: Stripe Webhook Secrets
# ===========================================
echo "  Checking for Stripe webhook secrets..."
WEBHOOK_PATTERN="whsec_[A-Za-z0-9]{20,}"
if echo "$STAGED_FILES" | xargs grep -lE "$WEBHOOK_PATTERN" 2>/dev/null; then
    echo -e "${RED}âŒ BLOCKED: Stripe webhook secret detected!${NC}"
    ERRORS_FOUND=1
fi

# ===========================================
# CHECK 3: Resend API Keys
# ===========================================
echo "  Checking for Resend API keys..."
RESEND_PATTERN="re_[A-Za-z0-9]{20,}"
if echo "$STAGED_FILES" | xargs grep -lE "$RESEND_PATTERN" 2>/dev/null; then
    echo -e "${RED}âŒ BLOCKED: Resend API key detected!${NC}"
    ERRORS_FOUND=1
fi

# ===========================================
# CHECK 4: Supabase Service Keys (JWT format)
# ===========================================
echo "  Checking for Supabase service keys..."
# Look for long JWT tokens that aren't in .env files
for file in $STAGED_FILES; do
    if [[ ! "$file" =~ \.env ]]; then
        if grep -E "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\.[A-Za-z0-9_-]{50,}\.[A-Za-z0-9_-]{20,}" "$file" 2>/dev/null; then
            echo -e "${RED}âŒ BLOCKED: JWT token (possibly Supabase key) in $file${NC}"
            ERRORS_FOUND=1
        fi
    fi
done

# ===========================================
# CHECK 5: Cloudflare API Tokens
# ===========================================
echo "  Checking for Cloudflare API tokens..."
CF_PATTERN="[A-Za-z0-9_-]{40}"
for file in $STAGED_FILES; do
    if [[ "$file" =~ \.(md|ts|tsx|js|json)$ ]] && [[ ! "$file" =~ \.env ]]; then
        # Check for patterns that look like CF tokens near "CLOUDFLARE" or "Authorization"
        if grep -iE "(cloudflare.*token|authorization.*bearer).*[A-Za-z0-9_-]{35,}" "$file" 2>/dev/null | grep -vE "YOUR_.*HERE|<.*>|\.\.\." > /dev/null; then
            echo -e "${YELLOW}âš ï¸  WARNING: Possible Cloudflare token in $file - please verify${NC}"
        fi
    fi
done

# ===========================================
# CHECK 6: OpenAI/OpenRouter API Keys
# ===========================================
echo "  Checking for OpenAI/OpenRouter keys..."
OPENAI_PATTERN="sk-[A-Za-z0-9]{20,}"
if echo "$STAGED_FILES" | xargs grep -lE "$OPENAI_PATTERN" 2>/dev/null; then
    echo -e "${RED}âŒ BLOCKED: OpenAI API key detected!${NC}"
    ERRORS_FOUND=1
fi

# ===========================================
# CHECK 6b: AWS Access Keys
# ===========================================
echo "  Checking for AWS access keys..."
AWS_ACCESS_PATTERN="AKIA[0-9A-Z]{16}"
if echo "$STAGED_FILES" | xargs grep -lE "$AWS_ACCESS_PATTERN" 2>/dev/null; then
    echo -e "${RED}âŒ BLOCKED: AWS Access Key ID detected!${NC}"
    echo "   Files containing AWS keys:"
    echo "$STAGED_FILES" | xargs grep -lE "$AWS_ACCESS_PATTERN" 2>/dev/null
    ERRORS_FOUND=1
fi

# ===========================================
# CHECK 6c: AWS Secret Keys
# ===========================================
echo "  Checking for AWS secret keys..."
# AWS secret keys are 40 characters, base64-like
for file in $STAGED_FILES; do
    if [[ "$file" =~ \.(md|ts|tsx|js|json|yaml|yml)$ ]] && [[ ! "$file" =~ \.env ]]; then
        # Look for aws_secret or secret_access_key followed by a 40-char string
        if grep -iE "(aws_secret|secret_access_key|aws_secret_access_key)\s*[:=]\s*['\"]?[A-Za-z0-9/+=]{40}['\"]?" "$file" 2>/dev/null; then
            echo -e "${RED}âŒ BLOCKED: AWS Secret Access Key detected in $file${NC}"
            ERRORS_FOUND=1
        fi
    fi
done

# ===========================================
# CHECK 7: Generic Secret Patterns
# ===========================================
echo "  Checking for generic secret patterns..."
for file in $STAGED_FILES; do
    if [[ "$file" =~ \.(md|ts|tsx|js)$ ]]; then
        # Check for hardcoded passwords or secrets
        if grep -iE "(password|secret|api_key|apikey)\s*[:=]\s*['\"][^'\"]{10,}['\"]" "$file" 2>/dev/null | grep -vE "YOUR_|<.*>|example|placeholder|\.\.\." > /dev/null; then
            echo -e "${YELLOW}âš ï¸  WARNING: Possible hardcoded secret in $file - please verify${NC}"
        fi
    fi
done

# ===========================================
# CHECK 8: .env files (should be gitignored)
# ===========================================
echo "  Checking for .env files..."
if echo "$STAGED_FILES" | grep -E "^\.env$|^\.env\." | grep -v "\.env\.example" > /dev/null; then
    echo -e "${RED}âŒ BLOCKED: .env file should not be committed!${NC}"
    echo "   Add to .gitignore: .env*"
    ERRORS_FOUND=1
fi

# ===========================================
# FINAL RESULT
# ===========================================
echo ""
if [ $ERRORS_FOUND -eq 1 ]; then
    echo -e "${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${RED}â•‘  COMMIT BLOCKED: Secrets detected in staged files!        â•‘${NC}"
    echo -e "${RED}â•‘                                                            â•‘${NC}"
    echo -e "${RED}â•‘  Please remove secrets and use:                            â•‘${NC}"
    echo -e "${RED}â•‘  - Cloudflare Worker secrets (wrangler secret put)         â•‘${NC}"
    echo -e "${RED}â•‘  - Local .env files (gitignored)                           â•‘${NC}"
    echo -e "${RED}â•‘                                                            â•‘${NC}"
    echo -e "${RED}â•‘  To bypass (NOT RECOMMENDED): git commit --no-verify       â•‘${NC}"
    echo -e "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    exit 1
else
    echo -e "${GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${GREEN}â•‘  âœ“ All security checks passed!                             â•‘${NC}"
    echo -e "${GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    exit 0
fi
